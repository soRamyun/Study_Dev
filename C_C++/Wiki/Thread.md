# Thread

## 1. 프로세스란

- 운영체제에 의해 메모리 공간을 할당받아 CPU에서 실행/제어되고 있는 프로그램이다.
- CPU 스케줄링의 대상이 되는 작업
  * CPU 스케줄러(CPU Scheduler)는 프로세스가 생성된 후 종료될때까지 모든 상태 변화를 조정하는 일
  * CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당

 ## 2. 쓰레드(Thread)란

<img src = 'https://goodgid.github.io/assets/img/os/what_is_thread_1.png' width = "700" title="Thread"></img>

- 프로세스 실행의 단위이며 하나의 프로세스는 여러개의 쓰레드로 구성이 가능하다.
- 하나의 프로세스를 구성하는 프로세스에 할당된 메모리, 자원 등을 공유한다.
- 프로세스와 같이 실행, 준비, 대기 등의 실행 상태를 가지며 실행 상태가 변할때마다 **쓰레드 문맥교환(context switching)**을 수행한다.
- 각 쓰레드별로 자신만의 **스택**과 **레지스터**를 가진다. 나머지 영역 Code, Data, Heap은 부모 프로세스 영역에서 공유한다.
- 한순간에 하나의 쓰레드만 실행 가능하다.

### 2.1 context switching

- 멀티프로세스 환경에서 CPU가 **어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업**을 Context Switch(Context Switching)라고 한다.

#### 2.1.1 context란

-  CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들로 프로세스의 **PCB(Process Control Block)**에 저장한다. 
-  context switching이 발생했을 때 PCB의 정보를 읽어(적재) CPU가 전에 프로스세가 일을 하던 것에 이어서 수행한다.

#### 2.1.2 PCB(Process Control Block)

<img src = 'https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdxYApr%2Fbtq2plns3mV%2F1D0GBGfg2SNnk3C995ZFI0%2Fimg.png' width = "500" title="PCB"></img>

- PCB의 저장정보 
  - 프로세스 상태 : 생성, 준비, 수행, 대기, 중지
  - 프로스램 카운터
  - 레시스터
  - 프로세스 번호
- CPU가 어떤 프로세스를 실행하고 있는 상태에서 인터럽트에 의해 다음 우선 순위를 가진 프로세스가 실행되어야 할 때 기존의 프로세스 정보들은 PCB에 저장하고 다음 프로세스의 정보를 PCB에서 가져와 교체

## 3. 쓰레드와 프로세스의 차이

- 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 쓰레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
- 쓰레드는 **독립적인 작업**을 수행해야 하기 때문에 각자의 **스택**과 **PC 레지스터 값**을 갖고 있다.
  - 독립적인 작업 : 워드를 예를 들어서 문자를 입력하는 동안, 자동저장하고 맞춤법 검사도 하는 것으로 각각 독립적인 쓰레드에 의해서 이루어진다.
  - **스택 메모리 공간**이 **독립적**이라는 것은 **독립적인 함수 호출**이 가능하다는 것이고 이는 **독립적인 실행 흐름**이 가능하게 한다.
  - PC (Program Counter) 레지스터: 다음 인출(Fetch) 될 명령어의 주소를 가지고 있는 레지스터로 쓰레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.
- 각 프로세스는 독립적으로 실행되며 각각 별개의 메모리를 차지하고 있는 것과 달리 멀티스레드는 프로세스 내의 메모리를 공유해 사용할 수 있다. 
- 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠르다.

## 4.동기화

- 각각의 스레드 중 어떤 것이 먼저 실행될지 그 순서를 알 수 없다는 것이 있다. 예를 들어, 두 스레드가 특정 공유 변수 i의 값을 1 증가시키는 명령을 실행할 때, 다음과 같은 방식으로 수행될 수 있다.

  - 1. 공유되는 변수 i의 값을 [레지스터](https://ko.wikipedia.org/wiki/프로세서_레지스터)에 저장
  - 2. 레지스터의 값을 1 증가시킨다.
  - 3. 변수 i에 그 값을 저장한다.

  이때 두 스레드가 실행될 때 어떤 스레드가 먼저 실행될지는 보장되지 않으며, 만약 다음과 같은 순서로 실행된다면 최종 결과로 i는 2가 증가된다. 

  |  스레드  |           동작           | i의 값 | 스레드 1의 레지스터 | 스레드 2의 레지스터 |
  | :------: | :----------------------: | :----: | :-----------------: | :-----------------: |
  | 스레드 1 | i의 값을 레지스터에 저장 |   0    |          0          |                     |
  | 스레드 1 |   레지스터 값을 1 증가   |   0    |          1          |                     |
  | 스레드 1 |       i에 값 저장        | **1**  |          1          |                     |
  | 스레드 2 | i의 값을 레지스터에 저장 |   1    |          1          |          1          |
  | 스레드 2 |   레지스터 값을 1 증가   |   1    |          1          |          2          |
  | 스레드 2 |       i에 값 저장        | **2**  |          1          |          2          |

  하지만 다음과 같이 실행된다면 최종 결과로 i는 1이 증가된다.
  
  |  스레드  |           동작           | i의 값 | 스레드 1의 레지스터 | 스레드 2의 레지스터 |
  | :------: | :----------------------: | :----: | :-----------------: | :-----------------: |
  | 스레드 1 | i의 값을 레지스터에 저장 |   0    |          0          |                     |
  | 스레드 2 | i의 값을 레지스터에 저장 |   0    |          0          |          0          |
  | 스레드 1 |   레지스터 값을 1 증가   |   0    |          1          |          0          |
  | 스레드 2 |   레지스터 값을 1 증가   |   0    |          1          |          1          |
  | 스레드 1 |       i에 값 저장        | **1**  |          1          |          1          |
  | 스레드 2 |       i에 값 저장        | **1**  |          1          |          1          |

	이것은 원래 프로그램의 의도(각각의 스레드가 i를 1씩 증가하는 동작)와 다를 수 있다. 또한 이러한 문제는 스레드의 실행 조건에 따라 결과가 다르게 나오므로, 오류가 발생했을 때 원인을 찾기가 힘들다. 이러한 문제를 경쟁 조건이라고 하며, 문제를 막기 위해 뮤텍스와 같은 방법을 통해 공유 데이터에 접근하는 스레드의 개수를 한개 이하로 유지하는 방법을 사용할 수 있다.

## 5. 뮤텍스(Mutual Exclusion)와 세마포어(Semaphore)

- 뮤텍스(Mutual Exclusion) 
  - 쓰레드의 **동시 접근**을 허용하지 않는다는 의미이다. 
  - 뮤텍스의 쓰레드 동기화 방법은 **임계영역**에 들어가기 위해 이 **뮤텍스를 가지고 있어야** 들어갈 수 있다.일종의 자물쇠와 같은 역할을 한다. 임계영역에 들어간 쓰레드가 뮤텍스를 이용해 임계영역에서 본인이 나올때까지 다른 쓰레드가 못들어오게 내부에서 자물쇠로 잠근다.
  - 한 쓰레드, 프로세스에 의해 소유될 수 있는 **Key**🔑를 기반으로 한 상호배제기법

- 세마포어(Semaphore)
  - 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법
  - 예를 들어  세마포어를 이용하는 레스토랑의 화장실에는 여러 개의 칸이 있다. 그리고 화장실 입구에는 현재 화장실의 빈 칸 개수를 보여주는 전광판이 있어 빈칸의 개수가 없으면 대기해야한다.

## 6. 소스코드

```C
#include <stdio.h>
#include <pthread.h>	//window에서는 지원되지 않아 라이브러리 설치 및 설정해야함
int a = 0;
p_thread_mutex_t mutex;

void * thread1(void * arg)
{
    printf("arg : %d\n", (int)arg);
    
	while(1){
        pthread_mutex_lock(&mutex);		
        printf("thread%d : a[%d]\n", (int)arg ,++a);
        pthread_mutex_unlock(&mutex);
        Sleep(2);
    }
    return NULL;
}

int main(void)
{
    int idl = 77;
    int id2 = 88;
    
    pthread_t s_thread[2];			//pthread_t는 윈도우 handle값을 가지게 됨.
    pthead_mutex_init(&mutex, NULL); //mutex 초기화는 반드시 해줘야함.
    
    pthread_create(&s_thread[0], NULL, thread1, (void *)idl);
    pthread_create(&s_thread[1], NULL, thread1, (void *)id2);
    
    pthread_join(s_thread[0], NULL);
    pthread_join(s_thread[1], NULL);
}
```

---

## 참고사이트 & 출처

[쓰레드(Thread)란 무엇인가?](https://goodgid.github.io/What-is-Thread/)

[[스레드(Thread) - 개념, 사용이유, 프로세스와의 비교, 상태, 우선순위, 종류](https://beststar-1.tistory.com/6)]

[CPU 스케줄링](https://bnzn2426.tistory.com/65)

[컨텍스트 스위칭이란](https://applefarm.tistory.com/105?category=926699)

[위키백과](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85))

[뮤텍스(Mutex)와 세마포어(Semaphore)의 차이](https://worthpreading.tistory.com/90)

[오제이튜브](https://www.youtube.com/watch?v=GLMNFOCiGSU&list=PLz--ENLG_8TMdMJIwyqDIpcEOysvNoonf&index=23)

[c++ 쓰레드](https://nowonbun.tistory.com/732)
